## 1) Критичные несоответствия (ломают `make setup` / сборку / prod)

### 1.1. `Makefile: check-files` проверяет файлы, которых в репозитории нет (или названы иначе)
В `Makefile` target `check-files` ожидает, например:
- `docker/php.Dockerfile` — **но реально** Dockerfile’ы: `docker/php.pgsql.Dockerfile` и `docker/php.mysql.Dockerfile`
- также проверяются `docker/php/php.ini`, `docker/php/www.conf`, `docker/nginx/conf.d/laravel.conf` — по структуре репо они **могут** быть, но факт: сейчас проверка завязана на конкретные пути/имена и уже точно **расходится** по `docker/php.Dockerfile`.

**Нужно исправить (одно из):**
- обновить `Makefile`, чтобы он проверял **существующие** файлы (`docker/php.pgsql.Dockerfile` и/или `docker/php.mysql.Dockerfile`) и реально используемые конфиги;
- либо добавить “алиас”-файл `docker/php.Dockerfile` (но это хуже, т.к. у вас выбор БД через отдельные Dockerfile).

---

### 1.2. Production Nginx-образ не содержит код приложения (скорее всего будет 404 на статику/entrypoint)
`docker/nginx.Dockerfile` кладёт только конфиг Nginx. В `docker-compose.prod.yml` вы используете готовый образ `nginx:${IMAGE_TAG}` **без bind-mount кода**.

В итоге в prod:
- Nginx будет смотреть в `/var/www/laravel/public`,
- но **файлов там не будет**, если вы не “вшили” код в nginx image или не примонтировали volume.

**Нужно исправить (выбрать стратегию):**
1) **Вшивать `public/` (и при необходимости весь проект) в nginx-образ** на этапе CI;
   или
2) **Монтировать код в Nginx в prod compose** (хуже для “image-based” деплоя, но проще);
   или
3) Перестроить схему: Nginx отдаёт статику из общего read-only volume, который наполняет отдельный build job/контейнер.

---

### 1.3. Dockerfile’ы используют `php:8.5-*`, а по требованиям окружения лучше `PHP 8.4`
В обоих PHP Dockerfile указана версия **8.5**, что:
- может не существовать/не быть стабильной в вашем целевом окружении,
- противоречит принятой цели “предпочитать PHP 8.4”.

**Нужно исправить:**
- заменить базовый образ на `php:8.4-fpm-alpine` (и проверить совместимость расширений/PIE/Xdebug).

---

## 2) Сетевые/инфраструктурные несостыковки (ломают “external infra” контракт)

### 2.1. Объявлена external-сеть Redis, но сервисы к ней не подключены
В базовом `docker-compose.yml` объявлена внешняя сеть для Redis (external), но `laravel-php-nginx-socket` к ней **не подключён**. Это создаёт иллюзию “Redis предусмотрен”, но фактически контейнер не будет в той сети и не сможет резолвить хосты/доступаться туда, если доступ предполагается через эту сеть.

**Нужно исправить (одно из):**
- либо подключить `laravel-php-nginx-socket` к redis-сети,
- либо удалить сеть из compose, если Redis доступен просто по маршрутизации (обычный TCP наружу) и network не нужна,
- либо переименовать/унифицировать сети (см. пункт ниже).

### 2.2. Нейминг сетей выглядит несогласованным
Есть `postgres-dev-network` (external) и отдельно `redis-cluster-dev` (external). При этом ваша основная внутренняя сеть называется иначе. Это не “ошибка”, но снижает переносимость и предсказуемость.

**Нужно исправить:**
- унифицировать нейминг по шаблону, например: `external-postgres`, `external-redis`, `app-internal`;
- явно задокументировать: какие сети должны существовать заранее и как их создавать/подключать.

---

## 3) Dev- и базовый compose: “скрытые” зависимости и UX-проблемы

### 3.1. Переменные Xdebug в `docker-compose.yml` без дефолтов
Сейчас переменные пробрасываются как `${XDEBUG_MODE}`, `${XDEBUG_START}`, `${XDEBUG_CLIENT_HOST}`. Если они не заданы, Compose часто:
- подставит пустую строку,
- и/или будет ругаться предупреждениями.

**Нужно исправить:**
- задать дефолты через синтаксис `${VAR:-default}` (например, `off/no/host.docker.internal`) и описать их в `.env.docker`.

### 3.2. `depends_on` в dev: Nginx зависит от Node
В dev-файле Nginx зависит от Node-сервиса. Это не всегда нужно и иногда мешает (например, backend можно поднимать без фронта).

**Нужно исправить (по желанию, но рекомендуется):**
- убрать жёсткую зависимость, либо сделать её опциональной через отдельный профиль/override.

---

## 4) Документация: что стоит синхронизировать

### 4.1. README/SETUP vs фактические файлы и версии
Документация обещает определённые пути/контракты и “быстрый старт”, но:
- `Makefile` уже расходится с реальными именами Dockerfile,
- версия PHP в Dockerfile сейчас 8.5,
- prod-схема с nginx image не объясняет, **где берётся код**.

**Нужно исправить:**
- привести README/SETUP в соответствие с реальными файлами и жизненным циклом (dev vs prod).

---

## 5) Мини-чеклист обязательных правок (в порядке приоритета)

1) **Починить `Makefile check-files`**: проверять реальные Dockerfile’ы и реальные конфиги.
2) **Определиться с prod-поставкой кода для Nginx** (иначе prod overlay нерабочий).
3) **Перейти на `php:8.4-fpm-alpine`** в обоих PHP Dockerfile и прогнать сборку.
4) **Привести сети external infra в порядок**: либо подключить PHP-сервис к redis-сети, либо удалить/переименовать, и то же по postgres.
5) **Добавить дефолты для Xdebug-переменных** в compose (и описать в `.env.docker`).
6) (Опционально) Сделать Node/Vite менее “обязательным” для запуска Nginx в dev.

---

Если скажете, можно ли менять файлы прямо сейчас, я подготовлю **конкретные правки в виде сниппетов** (Makefile + compose + Dockerfile’ы) так, чтобы:
- `make setup` проходил с нуля,
- dev работал с bind-mount,
- prod работал на образах без “пропавшего кода”,
- и всё было согласовано с external DB/Redis.